# Phase 6: Frontend - Gallery & Advanced Features

## Phase Goal

Implement the gallery feature for browsing historical generations, add sound effects for user interactions, create the breathing background animation, and add final polish features to match the full feature parity of pixel-prompt-js.

**Success Criteria**:
- Gallery displays previews of all past generations
- User can click a gallery preview to load all 9 images from that session
- Sound effects play on button clicks and interactions
- Breathing background animation runs continuously
- Expandable sections work correctly
- All features from pixel-prompt-js are replicated
- UI is polished and production-ready

**Estimated Tokens**: ~40,000

---

## Prerequisites

- Phase 5 complete (core generation UI working)
- Sound files copied to frontend/assets/sounds/
- Reference components from pixel-prompt-js

---

## Tasks

### Task 1: Gallery Module - S3 Listing

**Goal**: Create module to list and fetch gallery items from S3

**Files to Create**:
- `/frontend/src/hooks/useGallery.js` - Gallery data hook
- `/frontend/src/utils/s3Helpers.js` - S3 listing utilities

**Prerequisites**: Phase 5 complete

**Implementation Steps**:

1. Create `s3Helpers.js` with S3 listing functions:
   - `listGalleryFolders(s3Client)` → returns list of folders
   - `listGalleryImages(s3Client, folder)` → returns images in folder
   - Use S3 SDK (install `@aws-sdk/client-s3` if using browser SDK)
   - Alternative: Create Lambda endpoint `/gallery/list` and use API client

2. Note: Browser cannot directly access S3 (CORS, credentials)
   - Recommended approach: Add Lambda endpoints for gallery listing
   - Or: Use pre-signed URLs generated by backend
   - Or: List via CloudFront with S3 XML listing enabled

3. Create `useGallery.js` hook:
   ```javascript
   function useGallery() {
     const [galleries, setGalleries] = useState([]);
     const [selectedGallery, setSelectedGallery] = useState(null);
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState(null);

     const fetchGalleries = async () => {
       // Fetch list of gallery folders
     };

     const loadGallery = async (galleryId) => {
       // Fetch all images from gallery
     };

     return { galleries, selectedGallery, loading, error, fetchGalleries, loadGallery };
   }
   ```

4. Implement `fetchGalleries()`:
   - Call backend endpoint (new: `GET /gallery/list`)
   - Returns array of gallery folders: `[{id: "2025-11-15-14-30-45", preview: "..."}]`
   - For each folder, get one random image as preview
   - Store in state

5. Implement `loadGallery(galleryId)`:
   - Call backend endpoint (new: `GET /gallery/{galleryId}`)
   - Returns all images from that folder
   - Parse and convert to display format
   - Update selectedGallery state

6. Add backend endpoints (in Lambda):
   - `GET /gallery/list`: List all folders, return with preview images
   - `GET /gallery/{galleryId}`: Return all images from folder

**Verification Checklist**:
- [ ] useGallery hook fetches galleries successfully
- [ ] Gallery list includes preview images
- [ ] loadGallery fetches all images from selected gallery
- [ ] Backend endpoints work correctly
- [ ] Error handling for failed fetches

**Testing Instructions**:
- Create test generations to populate gallery
- Call fetchGalleries() and verify list returned
- Call loadGallery() and verify images returned
- Test with empty gallery (no generations yet)
- Test error handling (backend down)

**Commit Message Template**:
```
feat(frontend): implement gallery data fetching

- Create useGallery hook for gallery management
- Add s3Helpers for S3 operations
- Implement fetchGalleries and loadGallery functions
- Add backend endpoints for gallery listing
- Handle errors and loading states
```

**Estimated Tokens**: ~5,000

---

### Task 2: Gallery UI Component

**Goal**: Create gallery UI for browsing and selecting past generations

**Files to Create**:
- `/frontend/src/components/gallery/GalleryBrowser.jsx`
- `/frontend/src/components/gallery/GalleryBrowser.module.css`
- `/frontend/src/components/gallery/GalleryPreview.jsx`

**Prerequisites**: Task 1 complete, reference `/pixel-prompt-js/components/ImageGrid.js`

**Implementation Steps**:

1. Create `GalleryPreview.jsx` component:
   - Props: `gallery` (object with id, preview image, date)
   - Render preview image in card
   - Show date/timestamp
   - Clickable to load full gallery
   - Hover effect (scale up slightly)

2. Create `GalleryBrowser.jsx` component:
   - Use `useGallery()` hook
   - Display grid of GalleryPreview components
   - Show loading state while fetching
   - Show empty state if no galleries

3. Implement gallery selection:
   - Click preview → call `loadGallery(galleryId)`
   - Show loading overlay
   - When loaded, display all 9 images in main image grid
   - Highlight selected gallery in browser

4. Layout the gallery browser:
   - Horizontal scrollable row of previews (like film strip)
   - Or grid layout if many galleries
   - Position: Below main controls, above image grid
   - Collapsible: Can hide gallery browser to save space

5. Add pagination (if many galleries):
   - Show 10-20 galleries at a time
   - "Load More" button
   - Or infinite scroll

6. Style the gallery browser:
   - Preview cards with border and shadow
   - Selected state (highlight border)
   - Responsive: Horizontal scroll on mobile, grid on desktop

**Verification Checklist**:
- [ ] Gallery browser displays previews
- [ ] Click preview loads full gallery
- [ ] Selected gallery is highlighted
- [ ] Loading states work
- [ ] Empty state shows when no galleries
- [ ] Responsive design works

**Testing Instructions**:
- Generate several images to create galleries
- Open gallery browser and verify previews shown
- Click preview and verify all 9 images load
- Test with many galleries (pagination/scroll)
- Test on mobile (horizontal scroll)
- Verify loading and empty states

**Commit Message Template**:
```
feat(frontend): create gallery browser UI

- Add GalleryPreview component for individual galleries
- Create GalleryBrowser with grid/scroll layout
- Implement gallery selection and loading
- Add loading and empty states
- Style with responsive design
```

**Estimated Tokens**: ~5,000

---

### Task 3: Sound Effects Module

**Goal**: Add sound effects for user interactions

**Files to Create**:
- `/frontend/src/hooks/useSound.js` - Sound playback hook
- `/frontend/src/components/common/SoundPlayer.jsx` - Sound player component

**Prerequisites**: Task 2 complete, reference `/pixel-prompt-js/components/Sounds.js`

**Implementation Steps**:

1. Copy sound files to `/frontend/src/assets/sounds/`:
   - `click.wav` - Button click sound
   - `switch.wav` - Toggle switch sound
   - `swoosh.wav` - Transition sound
   - `expand.mp3` - Expand section sound

2. Create `useSound.js` hook:
   ```javascript
   function useSound() {
     const [sounds, setSounds] = useState({});

     useEffect(() => {
       // Preload sounds
       const audio = {
         click: new Audio('/assets/sounds/click.wav'),
         switch: new Audio('/assets/sounds/switch.wav'),
         swoosh: new Audio('/assets/sounds/swoosh.wav'),
         expand: new Audio('/assets/sounds/expand.mp3')
       };
       setSounds(audio);
     }, []);

     const playSound = (soundName) => {
       if (sounds[soundName]) {
         sounds[soundName].currentTime = 0; // Reset to start
         sounds[soundName].play().catch(err => console.log('Sound play failed:', err));
       }
     };

     return { playSound };
   }
   ```

3. Create `SoundPlayer.jsx` component:
   - Accept props: `soundToPlay` (name of sound)
   - Use `useSound()` hook
   - Play sound when `soundToPlay` changes
   - Handle autoplay restrictions (user must interact first)

4. Integrate sounds into components:
   - Generate button click: Play "click" sound
   - Parameter slider change: Play "switch" sound
   - Gallery preview click: Play "swoosh" sound
   - Expand/collapse sections: Play "expand" sound

5. Add mute toggle:
   - Button to mute/unmute sounds
   - Store preference in localStorage
   - Respect user preference on page load

6. Handle browser autoplay restrictions:
   - Sounds only work after user interaction
   - Show notice if autoplay blocked
   - Graceful fallback (no crash if sound fails)

**Verification Checklist**:
- [ ] Sounds preload on app mount
- [ ] playSound() plays correct sound
- [ ] Sounds play on button clicks
- [ ] Sounds play on slider changes
- [ ] Mute toggle works and persists
- [ ] No errors if sound playback fails

**Testing Instructions**:
- Click generate button, verify click sound
- Move sliders, verify switch sound
- Click gallery preview, verify swoosh sound
- Toggle mute and verify sounds stop
- Refresh page and verify mute preference persists
- Test in browser with strict autoplay policy (check console for errors)

**Commit Message Template**:
```
feat(frontend): add sound effects for interactions

- Create useSound hook for sound playback
- Add SoundPlayer component
- Integrate sounds (click, switch, swoosh, expand)
- Add mute toggle with localStorage persistence
- Handle browser autoplay restrictions gracefully
```

**Estimated Tokens**: ~4,000

---

### Task 4: Breathing Background Animation

**Goal**: Create subtle breathing background animation

**Files to Create**:
- `/frontend/src/components/common/BreathingBackground.jsx`
- `/frontend/src/components/common/BreathingBackground.module.css`

**Prerequisites**: Task 3 complete, reference `/pixel-prompt-js/components/Breathing.js`

**Implementation Steps**:

1. Create `BreathingBackground.jsx` component:
   - Renders full-screen background layer
   - Animated gradient or color shift
   - Subtle pulsing effect (scale or opacity)

2. Implement animation:
   - Use CSS animations or React Animated (prefer CSS for performance)
   - Keyframes for breathing effect:
     ```css
     @keyframes breathe {
       0%, 100% { transform: scale(1); opacity: 0.5; }
       50% { transform: scale(1.05); opacity: 0.7; }
     }
     ```
   - Duration: 6-8 seconds (slow, calm breathing)
   - Infinite loop

3. Style the background:
   - Position: fixed, full viewport
   - Z-index: -1 (behind all content)
   - Gradient: Subtle dark colors (purple, blue, black)
   - Blur or filter effects for atmosphere

4. Optimize performance:
   - Use `will-change: transform` for GPU acceleration
   - Avoid animating expensive properties (e.g., box-shadow)
   - Test on low-end devices (disable if laggy)

5. Add toggle:
   - User preference to disable animation
   - Store in localStorage
   - Some users may find animation distracting

**Verification Checklist**:
- [ ] Background animation is visible
- [ ] Animation is smooth (60fps)
- [ ] Doesn't interfere with content readability
- [ ] Performance is good (no lag)
- [ ] Toggle works to disable animation

**Testing Instructions**:
- View app and observe background breathing
- Verify smooth animation (no stuttering)
- Test on low-end device or throttle CPU
- Toggle animation off and verify it stops
- Verify content is still readable with animation

**Commit Message Template**:
```
feat(frontend): add breathing background animation

- Create BreathingBackground component
- Implement CSS keyframe animation (6s loop)
- Style with subtle gradient and pulsing effect
- Optimize with GPU acceleration
- Add toggle to disable animation
```

**Estimated Tokens**: ~3,500

---

### Task 5: Expandable Sections Component

**Goal**: Create collapsible sections for organizing UI

**Files to Create**:
- `/frontend/src/components/common/Expand.jsx`
- `/frontend/src/components/common/Expand.module.css`

**Prerequisites**: Task 4 complete, reference `/pixel-prompt-js/components/Expand.js`

**Implementation Steps**:

1. Create `Expand.jsx` component:
   - Props: `title`, `children`, `defaultExpanded`, `onToggle`
   - Renders header with title and expand/collapse icon
   - Renders children (content) when expanded
   - Smooth height transition when toggling

2. Implement expand/collapse:
   - State: `isExpanded` (boolean)
   - Click header → toggle state
   - Animate height transition (CSS transition)
   - Rotate icon (arrow or chevron)

3. Handle animations:
   - Expanding: Height 0 → auto (with transition)
   - Collapsing: Height auto → 0
   - Icon rotation: 0deg → 180deg
   - Use CSS transition for smooth effect

4. Add sound effect:
   - Play "expand" sound on toggle
   - Use `useSound()` hook

5. Style the component:
   - Header: Button-like, clickable
   - Icon: Arrow or chevron that rotates
   - Content: Padded, smooth reveal
   - Responsive: Full width on mobile

6. Accessibility:
   - Proper ARIA attributes (aria-expanded)
   - Keyboard navigation (Enter/Space to toggle)
   - Focus state on header

**Verification Checklist**:
- [ ] Section expands and collapses smoothly
- [ ] Icon rotates on toggle
- [ ] Sound plays on toggle
- [ ] Keyboard accessible (Enter/Space)
- [ ] ARIA attributes are correct
- [ ] Multiple instances work independently

**Testing Instructions**:
- Create component with test content
- Click header and verify smooth expand
- Click again and verify collapse
- Test keyboard navigation
- Test with multiple Expand components on page
- Verify sound plays on toggle

**Commit Message Template**:
```
feat(frontend): create expandable sections component

- Add Expand component with smooth height transition
- Implement expand/collapse with icon rotation
- Add sound effect on toggle
- Make keyboard accessible
- Style with responsive design
```

**Estimated Tokens**: ~4,000

---

### Task 6: Advanced UI Features

**Goal**: Add remaining features for full parity with pixel-prompt-js

**Files to Create/Modify**:
- Various components as needed

**Prerequisites**: Tasks 1-5 complete

**Implementation Steps**:

1. Add model-specific status indicators:
   - Show which models are currently processing
   - Color-coded status (pending, in-progress, complete, error)
   - Progress bar for overall completion

2. Implement image expansion modal:
   - Click image → open full-screen modal
   - Show large version of image
   - Display model name, prompt, parameters
   - Navigation arrows to view other images
   - Close button or click outside to dismiss
   - Keyboard shortcuts (Esc to close, arrows to navigate)

3. Add prompt examples/seeds:
   - Button: "Random Prompt" or "Example"
   - Loads random prompt from seeds.json (copy from pixel-prompt-js)
   - Helps users get started

4. Implement parameters preset:
   - Quick buttons: "Fast" (low steps), "Quality" (high steps), "Creative" (high guidance)
   - One-click to set multiple parameters

5. Add copy-to-clipboard:
   - Button to copy prompt
   - Button to copy parameters
   - Toast notification on copy

6. Implement download images:
   - Download button on each image
   - Downloads as PNG with metadata
   - Filename: `{model}-{timestamp}.png`

7. Add keyboard shortcuts:
   - Ctrl+Enter: Generate
   - Ctrl+E: Enhance prompt
   - Ctrl+R: Random prompt
   - Esc: Clear/cancel
   - Show shortcut hints (tooltip or help modal)

**Verification Checklist**:
- [ ] Model status indicators show correctly
- [ ] Image expansion modal works
- [ ] Random prompt button works
- [ ] Parameter presets apply correctly
- [ ] Copy-to-clipboard works with toast
- [ ] Download images works
- [ ] Keyboard shortcuts work
- [ ] All features are accessible

**Testing Instructions**:
- Test each feature individually
- Verify keyboard shortcuts
- Test copy and download
- Test modal navigation
- Verify all features work on mobile
- Check accessibility with screen reader

**Commit Message Template**:
```
feat(frontend): add advanced UI features

- Add model-specific status indicators
- Implement image expansion modal with navigation
- Add random prompt button with seeds
- Create parameter presets (fast, quality, creative)
- Add copy-to-clipboard with toast notifications
- Implement download images feature
- Add keyboard shortcuts and hints
```

**Estimated Tokens**: ~6,000

---

### Task 7: Mobile Optimizations

**Goal**: Optimize UI and UX for mobile devices

**Files to Modify**:
- All component CSS files
- App layout

**Prerequisites**: Task 6 complete

**Implementation Steps**:

1. Review mobile layout:
   - Test on actual devices (iOS, Android)
   - Identify layout issues, overflow, tiny text, etc.
   - Use browser DevTools device emulation

2. Optimize touch targets:
   - All buttons: Min 44x44px
   - Sliders: Larger thumb (min 44px)
   - Gallery previews: Larger for easier tapping

3. Adjust font sizes:
   - Ensure text is readable (min 16px body text)
   - Headers scale appropriately
   - No tiny text

4. Fix overflow and scrolling:
   - Horizontal scroll only where intended (gallery)
   - Prevent accidental horizontal scroll
   - Proper overflow handling in modals

5. Optimize animations:
   - Reduce or disable heavy animations on mobile
   - Use `prefers-reduced-motion` media query
   - Prioritize performance over aesthetics

6. Handle mobile keyboards:
   - Prevent input zoom (font-size: 16px min)
   - Proper input types (text, number)
   - Smooth scroll when keyboard appears

7. Test gestures:
   - Swipe to navigate images in modal
   - Pull to refresh (disable if conflicts)
   - Pinch to zoom on images (enable)

8. Optimize for slow networks:
   - Show loading states immediately
   - Optimize image sizes
   - Progressive loading
   - Retry failed loads

**Verification Checklist**:
- [ ] All touch targets are large enough
- [ ] Text is readable on small screens
- [ ] No horizontal overflow
- [ ] Animations perform well
- [ ] Keyboard doesn't cause layout issues
- [ ] Gestures work naturally
- [ ] Works on slow networks

**Testing Instructions**:
- Test on real iPhone and Android device
- Test with slow network (3G throttling)
- Test in portrait and landscape
- Verify all interactions work with touch
- Check accessibility (font scaling)
- Run Lighthouse mobile audit

**Commit Message Template**:
```
feat(frontend): optimize for mobile devices

- Increase touch target sizes (min 44px)
- Adjust font sizes for readability
- Fix overflow and scrolling issues
- Reduce animations on mobile
- Handle mobile keyboard properly
- Add swipe gestures for image modal
- Optimize for slow networks
```

**Estimated Tokens**: ~5,000

---

### Task 8: Final Polish and Testing

**Goal**: Final polish, bug fixes, and comprehensive testing

**Files to Modify**:
- All components as needed

**Prerequisites**: Tasks 1-7 complete

**Implementation Steps**:

1. Visual polish:
   - Review all components for visual consistency
   - Ensure spacing, colors, fonts match design
   - Fix any visual bugs or glitches
   - Smooth all animations
   - Add micro-interactions (hover effects, etc.)

2. Performance optimization:
   - Run Lighthouse audit
   - Optimize bundle size (code splitting, lazy loading)
   - Optimize images (compress, WebP format)
   - Remove unused dependencies
   - Minimize CSS and JS

3. Error handling review:
   - Test all error scenarios
   - Ensure error messages are helpful
   - Add error boundaries for graceful failure
   - Log errors for debugging

4. Accessibility audit:
   - Run axe or WAVE accessibility checker
   - Fix all violations
   - Test with screen reader
   - Ensure keyboard navigation works everywhere
   - Check color contrast

5. Cross-browser testing:
   - Test in Chrome, Firefox, Safari, Edge
   - Fix browser-specific issues
   - Use autoprefixer for CSS compatibility
   - Polyfills if needed

6. Comprehensive testing:
   - Test all features end-to-end
   - Test edge cases (empty states, errors, limits)
   - Test rapid interactions (spam clicking)
   - Test concurrent usage (multiple tabs)
   - Load testing (many galleries)

7. Documentation:
   - Update README with features and usage
   - Document known issues
   - Add troubleshooting guide
   - Screenshot gallery for documentation

**Verification Checklist**:
- [ ] Visual design is polished and consistent
- [ ] Lighthouse score > 90 (performance, accessibility)
- [ ] All errors handled gracefully
- [ ] Accessibility violations fixed
- [ ] Works in all major browsers
- [ ] All features tested and working
- [ ] Documentation is complete

**Testing Instructions**:
- Run full test suite
- Perform manual testing of all features
- Run Lighthouse and fix issues
- Test in all browsers
- Get user feedback (if possible)
- Fix all critical bugs before release

**Commit Message Template**:
```
feat(frontend): final polish and optimization

- Polish visual design and animations
- Optimize performance (bundle size, lazy loading)
- Fix all accessibility violations
- Add comprehensive error handling
- Test and fix cross-browser issues
- Update documentation with features and usage
```

**Estimated Tokens**: ~4,500

---

## Phase Verification

### Complete Phase Checklist

Before moving to Phase 7, verify:

- [ ] Gallery browser displays past generations
- [ ] Can select and load galleries
- [ ] Sound effects play on interactions
- [ ] Breathing background animates smoothly
- [ ] Expandable sections work
- [ ] All advanced features implemented (modal, download, copy, shortcuts)
- [ ] Mobile optimizations complete
- [ ] Final polish and testing done

### Feature Parity Checklist

Compare with pixel-prompt-js to ensure parity:

- [ ] Prompt input with character count and clear
- [ ] Parameter sliders (steps, guidance)
- [ ] Generate button with loading states
- [ ] Prompt enhancement
- [ ] Image grid with 9 models
- [ ] Progressive loading as models complete
- [ ] Gallery browser with previews
- [ ] Sound effects on interactions
- [ ] Breathing background
- [ ] Expandable sections
- [ ] Image expansion modal
- [ ] Download images
- [ ] Copy prompt/parameters
- [ ] Keyboard shortcuts
- [ ] Responsive mobile design

### Performance Benchmarks

Run Lighthouse audit and verify:
- Performance: > 90
- Accessibility: 100
- Best Practices: > 90
- SEO: > 90

Bundle size targets:
- JavaScript: < 500KB (gzipped)
- CSS: < 50KB (gzipped)
- Total page weight: < 1MB

### Known Limitations

- Gallery may be slow with 100+ generations (add pagination)
- Sound effects may not work on first load (autoplay restrictions)
- Some animations may lag on very old devices
- Limited to 9 models (backend constraint)

---

## Next Phase

Proceed to **[Phase 7: Integration Testing & Documentation](Phase-7.md)** for final testing and documentation.
